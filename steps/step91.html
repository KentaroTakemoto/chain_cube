<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chain Cube</title>
    <style>
        /* åŸºæœ¬ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã®è¨­å®š */
        body { margin: 0; overflow: hidden; background-color: #abeaff; font-family: 'Arial', sans-serif; }
        canvas { display: block; }

        /* ã‚¹ã‚³ã‚¢è¡¨ç¤ºã‚¨ãƒªã‚¢ã®ã‚¹ã‚¿ã‚¤ãƒ« */
        #top-ui {
            position: absolute;
            top: 20px;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 0 20px;
            box-sizing: border-box;
            pointer-events: none;
        }

        .score-container {
            background: rgba(255, 255, 255, 0.8);
            padding: 10px 25px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 4px 0 rgba(0,0,0,0.1);
            pointer-events: auto;
        }

        .score-value { font-size: 24px; font-weight: bold; color: #333; }
        
        /* ãƒªã‚»ãƒƒãƒˆãƒœã‚¿ãƒ³ã®ã‚¹ã‚¿ã‚¤ãƒ« */
        .reset-button {
            margin-top: 8px;
            padding: 6px 12px;
            font-size: 14px;
            font-weight: bold;
            background: #f44336;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 3px 0 #c62828;
            transition: transform 0.1s, box-shadow 0.1s;
        }
        .reset-button:active {
            transform: translateY(2px);
            box-shadow: 0 1px 0 #c62828;
        }

        /* æ“ä½œèª¬æ˜ã®ã‚¹ã‚¿ã‚¤ãƒ« */
        .instruction {
            position: absolute;
            bottom: 80px;
            width: 100%;
            text-align: center;
            color: #555;
            font-size: 18px;
            font-weight: bold;
            pointer-events: none;
            line-height: 1.5;
        }

        /* ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ç”»é¢ã®ã‚¹ã‚¿ã‚¤ãƒ« */
        #game-over-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            color: white;
            text-align: center;
        }

        .game-over-title { font-size: 48px; font-weight: bold; color: #ff5252; margin-bottom: 10px; }
        .final-score-label { font-size: 20px; margin-bottom: 5px; }
        .final-score-value { font-size: 60px; font-weight: bold; margin-bottom: 30px; }
        .retry-button {
            padding: 15px 40px;
            font-size: 24px;
            background: #4caf50;
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 6px 0 #2e7d32;
        }
        .retry-button:active { transform: translateY(4px); box-shadow: 0 2px 0 #2e7d32; }

        /* ãƒã‚¤ãƒ«ã‚¹ãƒˆãƒ¼ãƒ³ï¼ˆç¥ç¦ï¼‰ç”»é¢ã®ã‚¹ã‚¿ã‚¤ãƒ« */
        #milestone-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(255, 255, 255, 0.85);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            color: #333;
            text-align: center;
            cursor: pointer; /* å…¨ç”»é¢ã‚¯ãƒªãƒƒã‚¯å¯èƒ½ã§ã‚ã‚‹ã“ã¨ã‚’ç¤ºã™ */
        }
        .milestone-title { font-size: 48px; font-weight: bold; color: #ff9800; margin-bottom: 20px; }
        .milestone-message { font-size: 24px; font-weight: bold; margin-bottom: 10px; }
        .milestone-sub-message { font-size: 20px; color: #e91e63; font-weight: bold; margin-bottom: 40px; }
        .milestone-instruction { font-size: 16px; color: #777; animation: blink 1.5s infinite; }
        @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0; } }

        /* ãŠåŠ©ã‘ã‚¢ã‚¤ãƒ†ãƒ UIã®ã‚¹ã‚¿ã‚¤ãƒ« */
        #bottom-ui {
            position: absolute;
            bottom: 15px;
            width: 100%;
            display: flex;
            justify-content: center;
            gap: 30px;
            pointer-events: none;
            z-index: 10;
        }

        .item-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: #fff;
            border: 4px solid #f1f1f1;
            position: relative;
            pointer-events: auto;
            cursor: pointer;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
            transition: transform 0.1s, opacity 0.2s;
        }
        .item-btn:active {
            transform: scale(0.95);
        }
        .item-btn.disabled {
            opacity: 0.4;
            cursor: not-allowed;
            filter: grayscale(100%);
        }

        /* ãƒã‚¸ã‚«ãƒ«ã‚¢ã‚¤ã‚³ãƒ³ã®è‰²é®®ã‚„ã‹ãªã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³è¨­å®š */
        /* ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®é…è‰²ã«åˆã‚ã›ã¦èµ¤ãƒ»é’ãƒ»é»„ãƒ»ç·‘ã®4è‰²åˆ†å‰²ã«è¨­å®š */
        .magical-icon {
            width: 32px;
            height: 32px;
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: conic-gradient(#ff3333 0 25%, #33ccff 25% 50%, #ffcc00 50% 75%, #66ff33 75% 100%);
            border-radius: 4px;
            box-shadow: 0 0 10px rgba(255,255,255,0.8);
        }

        /* ãƒœãƒ ã‚¢ã‚¤ã‚³ãƒ³ã‚’çƒä½“ã¨å°ç«ç·šã§çˆ†å¼¾ã‚‰ã—ãè¡¨ç¾ */
        .bomb-icon {
            width: 32px;
            height: 32px;
            position: absolute;
            top: 55%; left: 50%;
            transform: translate(-50%, -50%);
            background: radial-gradient(circle at 30% 30%, #555, #111);
            border-radius: 50%;
        }
        /* çˆ†å¼¾ã®å£ï¼ˆå°ç«ç·šã®ä»˜ã‘æ ¹ï¼‰ */
        .bomb-icon::before {
            content: '';
            position: absolute;
            width: 100%; height: 6px;
            background: #222;
            top: -4px; left: 50%;
            transform: translateX(-50%);
            border-radius: 2px;
            width: 10px;
        }
        /* å°ç«ç·šã¨ç«èŠ±ã®è¡¨ç¾ */
        .bomb-icon::after {
            content: 'ğŸ”¥';
            position: absolute;
            top: -16px; right: -6px;
            font-size: 14px;
            filter: drop-shadow(0 0 2px orange);
        }

        .item-count {
            position: absolute;
            bottom: -6px;
            left: -6px;
            background: #ff9800;
            color: white;
            border-radius: 50%;
            width: 22px;
            height: 22px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 12px;
            font-weight: bold;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .item-key {
            position: absolute;
            bottom: -6px;
            right: -6px;
            background: #424242;
            color: white;
            border-radius: 6px;
            padding: 2px 6px;
            font-size: 12px;
            font-weight: bold;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
    </style>
</head>
<body>

<div id="top-ui">
    <div style="width: 50px;"></div>
    <div class="score-container">
        <div class="score-value" id="score">ã‚¹ã‚³ã‚¢ï¼š0</div>
        <div class="score-value" id="best-score" style="font-size: 16px; color: #777;">ãƒ™ã‚¹ãƒˆï¼š0</div>
        <button class="reset-button" onclick="handleReset()">ãƒªã‚»ãƒƒãƒˆ(Rã‚­ãƒ¼ã§ã‚‚å¯)</button>
    </div>
    <div style="width: 50px;"></div>
</div>

<div id="game-over-overlay">
    <div class="game-over-title">GAME OVER</div>
    <div class="final-score-label">ã‚¹ã‚³ã‚¢</div>
    <div id="final-score" class="final-score-value">0</div>
    <button class="retry-button" onclick="resetGame()">å†æŒ‘æˆ¦</button>
</div>

<div id="milestone-overlay" onclick="resumeFromMilestone()">
    <div class="milestone-title">ãŠã‚ã§ã¨ã†ï¼</div>
    <div class="milestone-message">åˆã‚ã¦ <span id="milestone-number">2K</span> ã®ã‚­ãƒ¥ãƒ¼ãƒ–ã‚’ä½œã‚Šã¾ã—ãŸ</div>
    <div class="milestone-sub-message">å°„å‡ºã•ã‚Œã‚‹ã‚­ãƒ¥ãƒ¼ãƒ–ãŒå€å¢—ï¼<br>ãŠåŠ©ã‘ã‚¢ã‚¤ãƒ†ãƒ ï¼‹ï¼‘</div>
    <div class="milestone-instruction">ã‚¯ãƒªãƒƒã‚¯ ã¾ãŸã¯ å°„å‡ºã‚­ãƒ¼ ã§å†é–‹</div>
</div>

<div class="instruction">å·¦å³ã‚­ãƒ¼ãƒ»A/Dã‚­ãƒ¼ãƒ»ãƒã‚¦ã‚¹ ã§ç§»å‹•<br>Enterãƒ»Spaceãƒ»Zã‚­ãƒ¼ãƒ»ã‚¯ãƒªãƒƒã‚¯ ã§ç™ºå°„<br>(ã‚¹ãƒãƒ›ã®å ´åˆã¯ãƒ‰ãƒ©ãƒƒã‚°ã§ç§»å‹•ã€æŒ‡ã‚’é›¢ã—ã¦ç™ºå°„)<br>(ãƒ‡ãƒãƒƒã‚°ç”¨) ä¸Šä¸‹ / W / S ã‚­ãƒ¼ã§æ•°å­—å¤‰æ›´</div> 
<div id="bottom-ui">
    <div id="btn-magical" class="item-btn" onclick="equipMagical()">
        <div class="magical-icon"></div>
        <div id="count-magical" class="item-count">1</div>
        <div class="item-key">X</div>
    </div>
    <div id="btn-bomb" class="item-btn" onclick="equipBomb()">
        <div class="bomb-icon"></div>
        <div id="count-bomb" class="item-count">1</div>
        <div class="item-key">C</div>
    </div>
</div>

<script type="importmap">
{
    "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js"
    }
}
</script>

<script type="module">
import * as THREE from 'three';
import * as CANNON from 'cannon-es';

// --- å®šæ•°å®šç¾© ---
const CUBE_SIZE = 1;      
const LANE_WIDTH = 4.5;   
const LANE_LENGTH = 8;   
const WALL_HEIGHT = 1.2;  
const SIDE_MARGIN = 0.05; 
const DEAD_LINE_Z = 0.0;  
const CUBE_SPEED = -18;

// --- ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•° ---
let scene, camera, renderer, playerCube;
let moveLeft = false, moveRight = false;
const moveSpeed = 0.1;

// ç‰©ç†æ¼”ç®—ãƒ»ã‚²ãƒ¼ãƒ ãƒ­ã‚¸ãƒƒã‚¯ç”¨
let world;
let physicsMaterial;
let physicsObjects = [];
let isShooting = false;
let isGameOver = false; 
let score = 0n; 
let highScore = 0n; 
let needsSave = false; 
const mergeQueue = [];
const bombQueue = [];

// ã‚¤ãƒ³ãƒ•ãƒ¬æ©Ÿèƒ½ã®ç®¡ç†ç”¨
let currentMinSpawn = 2n;       
let nextMilestone = 1000n;      
let isMilestonePaused = false;  

// ã‚¢ã‚¤ãƒ†ãƒ æ©Ÿèƒ½ã®ç®¡ç†ç”¨
let magicalCubeCount = 1;
let bombCubeCount = 1;
let currentPlayerCubeType = 'normal';

// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ç®¡ç†ç”¨
const particles = [];

// ã‚µã‚¦ãƒ³ãƒ‰ç®¡ç†ç”¨
let audioCtx = null;

// ãƒã‚¦ã‚¹ãƒ»ã‚¿ãƒƒãƒæ“ä½œç”¨
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
const dragPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), -(CUBE_SIZE / 2));

/**
 * ã‚µã‚¦ãƒ³ãƒ‰ã®åˆæœŸåŒ– (ãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œæ™‚ã«å‘¼ã³å‡ºã™)
 */
function initAudio() {
    if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
}

/**
 * åŠ¹æœéŸ³ã‚’å†ç”Ÿã™ã‚‹
 */
function playSound(type) {
    if (!audioCtx) return;
    
    // å¸¸ã«æœ€æ–°ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆçŠ¶æ…‹ã‚’ç¢ºèªã—ã€ä¸­æ–­ã•ã‚Œã¦ã„ã‚Œã°å†é–‹ã™ã‚‹
    if (audioCtx.state === 'suspended') {
        audioCtx.resume();
    }

    const masterGain = audioCtx.createGain();
    masterGain.gain.value = 0.1; // å…¨ä½“çš„ã«éŸ³é‡ã¯æ§ãˆã‚ã«è¨­å®š
    masterGain.connect(audioCtx.destination);

    const now = audioCtx.currentTime;

    if (type === 'shoot') {
        // ãƒã‚·ãƒ¥ãƒƒã¨ã„ã†å°„å‡ºéŸ³ (ãƒ›ãƒ¯ã‚¤ãƒˆãƒã‚¤ã‚º + å‘¨æ³¢æ•°æ¸›è¡°)
        const bufferSize = audioCtx.sampleRate * 0.1;
        const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
            data[i] = Math.random() * 2 - 1;
        }
        const noise = audioCtx.createBufferSource();
        noise.buffer = buffer;

        const filter = audioCtx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(1000, now);
        filter.frequency.exponentialRampToValueAtTime(100, now + 0.1);

        const envelope = audioCtx.createGain();
        envelope.gain.setValueAtTime(1.3, now);
        envelope.gain.exponentialRampToValueAtTime(0.01, now + 0.1);

        noise.connect(filter);
        filter.connect(envelope);
        envelope.connect(masterGain);
        noise.start();
    } 
    else if (type === 'merge') {
        // ãƒ”ãƒ­ãƒ³â™ªã¨ã„ã†åˆä½“éŸ³ (2ã¤ã®ã‚µã‚¤ãƒ³æ³¢ã®é€£ç¶š)
        const osc = audioCtx.createOscillator();
        const env = audioCtx.createGain();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(523.25, now); // C5
        osc.frequency.setValueAtTime(783.99, now + 0.05); // G5
        
        env.gain.setValueAtTime(0.2, now);
        env.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
        
        osc.connect(env);
        env.connect(masterGain);
        osc.start();
        osc.stop(now + 0.3);
    }
    else if (type === 'bomb') {
        // ãƒ‰ãƒ¼ãƒ³ã¨ã„ã†çˆ†ç™ºéŸ³ (ä½éŸ³ãƒã‚¤ã‚º)
        const osc = audioCtx.createOscillator();
        const env = audioCtx.createGain();
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(150, now);
        osc.frequency.exponentialRampToValueAtTime(40, now + 0.4);
        
        env.gain.setValueAtTime(0.5, now);
        env.gain.linearRampToValueAtTime(0, now + 0.5);
        
        osc.connect(env);
        env.connect(masterGain);
        osc.start();
        osc.stop(now + 0.5);
        
        // ä½åŸŸãƒã‚¤ã‚ºã®è¿½åŠ 
        const bufferSize = audioCtx.sampleRate * 0.4;
        const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
        const noise = audioCtx.createBufferSource();
        noise.buffer = buffer;
        const nFilter = audioCtx.createBiquadFilter();
        nFilter.type = 'lowpass';
        nFilter.frequency.value = 200;
        noise.connect(nFilter);
        nFilter.connect(env);
        noise.start();
    }
}

/**
 * ã‚­ãƒ©ã‚­ãƒ©ã—ãŸãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’ç”Ÿæˆã™ã‚‹
 */
function createMergeParticles(pos, colorStr, count = 20) {
    const color = new THREE.Color(colorStr);
    for (let i = 0; i < count; i++) {
        const geometry = new THREE.SphereGeometry(0.12, 6, 6);
        const material = new THREE.MeshBasicMaterial({ 
            color: color, 
            transparent: true, 
            opacity: 1.0 
        });
        const particle = new THREE.Mesh(geometry, material);
        
        particle.position.copy(pos);
        
        // å››æ–¹å…«æ–¹ã«é£›ã³æ•£ã‚‹é€Ÿåº¦ã‚’è¨­å®š
        const velocity = new THREE.Vector3(
            (Math.random() - 0.5) * 0.2,
            (Math.random() * 0.25) + 0.1,
            (Math.random() - 0.5) * 0.2
        );
        
        scene.add(particle);
        particles.push({
            mesh: particle,
            velocity: velocity,
            life: 1.0, // å¯¿å‘½
            decay: Math.random() * 0.02 + 0.02 // æ¸›è¡°ç‡
        });
    }
}

/**
 * ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®æ›´æ–°å‡¦ç†
 */
function updateParticles() {
    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.mesh.position.add(p.velocity);
        p.velocity.y -= 0.005; // é‡åŠ›
        p.life -= p.decay;
        p.mesh.material.opacity = p.life;
        p.mesh.scale.setScalar(p.life);

        if (p.life <= 0) {
            scene.remove(p.mesh);
            p.mesh.geometry.dispose();
            p.mesh.material.dispose();
            particles.splice(i, 1);
        }
    }
}

/**
 * æ•°å€¤ã«åŸºã¥ã„ãŸã‚­ãƒ¥ãƒ¼ãƒ–ã®è‰²ã‚’è¨ˆç®—ã™ã‚‹
 */
function getCubeColor(num) {
    let level = 0;
    let current = 2n;
    
    while (current < num && level < 1000) {
        current = getNextNumber(current);
        level++;
    }

    const baseColors = [
        0xff0000, 0xfb8c00, 0x8e24aa, 
        0x03a9f4, 0x7cb342, 0xe91e63  
    ];

    const colorIndex = level % 6;
    const cycle = Math.floor(level / 6);
    const color = new THREE.Color(baseColors[colorIndex]);
    
    const hsl = {};
    color.getHSL(hsl);
    hsl.l = Math.max(0.05, hsl.l - (cycle * 0.2));
    color.setHSL(hsl.h, hsl.s, hsl.l);

    return '#' + color.getHexString();
}

/**
 * æ•°å€¤ã‚’å˜ä½è¡¨è¨˜ã«å¤‰æ›ã™ã‚‹
 */
function formatNumber(num) {
    const n = BigInt(num);
    if (n < 1000n) return n.toString();
    const units = ["K", "M", "G", "T", "P", "E"];
    let unitIndex = -1;
    let tempN = n;
    while (tempN >= 1000n && unitIndex < units.length - 1) {
        tempN /= 1000n;
        unitIndex++;
    }
    return tempN.toString() + units[unitIndex];
}

/**
 * åˆä½“å¾Œã®æ¬¡ã®æ•°å€¤ã‚’è¨ˆç®—ã™ã‚‹
 */
function getNextNumber(num) {
    let next = num * 2n;
    let scale = 1n;
    for (let i = 0; i < 7; i++) {
        if (next === 1024n * scale) return 1000n * scale;
        scale *= 1000n;
    }
    return next;
}

/**
 * å¤‰æ›´å‰ã®æ•°å€¤ã‚’è¨ˆç®—ã™ã‚‹ï¼ˆãƒ‡ãƒãƒƒã‚°ç”¨ï¼‰
 */
function getPrevNumber(num) {
    let scale = 1n;
    for (let i = 0; i < 7; i++) {
        if (num === 1000n * scale) return 512n * (scale === 1n ? 1n : scale / 1000n);
        scale *= 1000n;
    }
    return num / 2n;
}

// ã‚²ãƒ¼ãƒ é–‹å§‹
init();
animate();

/**
 * å…¨ä½“ã®åˆæœŸåŒ–å‡¦ç†
 */
function init() {
    initPhysics();

    scene = new THREE.Scene();
    scene.background = new THREE.Color(0xabeaff);

    const aspect = window.innerWidth / window.innerHeight;
    camera = new THREE.PerspectiveCamera(40, aspect, 0.1, 1000);
    camera.position.set(0, 11, 12);
    camera.lookAt(0, -1, -2);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    // é«˜è§£åƒåº¦ãƒ‡ã‚£ã‚¹ãƒ—ãƒ¬ã‚¤ï¼ˆã‚¹ãƒãƒ›ç­‰ï¼‰ã§ã®ã¼ã‚„ã‘ã‚’è§£æ¶ˆã™ã‚‹ãŸã‚ã€ãƒ‡ãƒã‚¤ã‚¹ã®ãƒ”ã‚¯ã‚»ãƒ«æ¯”ã‚’è¨­å®š
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.9);
    scene.add(ambientLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
    dirLight.position.set(5, 15, 2);
    dirLight.castShadow = true;
    scene.add(dirLight);

    createStage();

    if (!loadGameState()) {
        const savedHighScore = localStorage.getItem('chainCubeHighScore');
        if (savedHighScore) highScore = BigInt(savedHighScore);
        updateScoreUI();
    }
    updateItemUI();

    spawnPlayerCube();

    window.addEventListener('keydown', (e) => handleKey(e, true));
    window.addEventListener('keyup', (e) => handleKey(e, false));
    window.addEventListener('resize', onWindowResize);
    window.addEventListener('beforeunload', saveGameState);

    // ãƒ‡ãƒã‚¤ã‚¹ã«å¿œã˜ãŸå°„å‡ºæ“ä½œã®æŒ¯ã‚Šåˆ†ã‘ã®ãŸã‚ã« pointerup ã‚¤ãƒ™ãƒ³ãƒˆã‚‚ç™»éŒ²ã™ã‚‹
    renderer.domElement.addEventListener('pointermove', onPointerMove);
    renderer.domElement.addEventListener('pointerdown', onPointerDown);
    renderer.domElement.addEventListener('pointerup', onPointerUp);
}

/**
 * ç‰©ç†ã‚¨ãƒ³ã‚¸ãƒ³ã®åˆæœŸåŒ–
 */
function initPhysics() {
    world = new CANNON.World();
    world.gravity.set(0, -10, 0); 

    physicsMaterial = new CANNON.Material('standard');
    const contactMaterial = new CANNON.ContactMaterial(physicsMaterial, physicsMaterial, {
        friction: 0.005,
        restitution: 0.1
    });
    world.addContactMaterial(contactMaterial);
}

/**
 * ã‚¹ãƒ†ãƒ¼ã‚¸ã®ç”Ÿæˆ
 */
function createStage() {
    const stageOffsetZ = -2;

    const floorGeo = new THREE.PlaneGeometry(LANE_WIDTH, LANE_LENGTH);
    const floorMat = new THREE.MeshPhongMaterial({ color: 0xe8e8e8 });
    const floor = new THREE.Mesh(floorGeo, floorMat);
    floor.rotation.x = -Math.PI / 2;
    floor.position.z = stageOffsetZ;
    floor.receiveShadow = true;
    scene.add(floor);

    const floorShape = new CANNON.Plane();
    const floorBody = new CANNON.Body({ mass: 0, shape: floorShape, material: physicsMaterial });
    floorBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
    world.addBody(floorBody);

    const lineMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 });
    for(let i = 0; i < 3; i++) {
        const dash = new THREE.Mesh(new THREE.PlaneGeometry(0.8, 0.15), lineMat);
        dash.rotation.x = -Math.PI / 2;
        dash.position.set((i - 1) * 1.4, 0.01, DEAD_LINE_Z + (CUBE_SIZE / 2));
        scene.add(dash);
    }

    const wallMat = new THREE.MeshPhongMaterial({ color: 0xe6a15c });
    const barrierHalfHeight = 10;

    const sideWallGeo = new THREE.BoxGeometry(0.2, WALL_HEIGHT, LANE_LENGTH);
    const leftWall = new THREE.Mesh(sideWallGeo, wallMat);
    leftWall.position.set(-(LANE_WIDTH / 2 + 0.1), WALL_HEIGHT / 2, stageOffsetZ);
    scene.add(leftWall);
    
    const leftWallShape = new CANNON.Box(new CANNON.Vec3(0.1, barrierHalfHeight, LANE_LENGTH / 2));
    const leftWallBody = new CANNON.Body({ mass: 0, shape: leftWallShape, material: physicsMaterial });
    leftWallBody.position.set(leftWall.position.x, barrierHalfHeight, stageOffsetZ);
    world.addBody(leftWallBody);

    const rightWall = new THREE.Mesh(sideWallGeo, wallMat);
    rightWall.position.set(LANE_WIDTH / 2 + 0.1, WALL_HEIGHT / 2, stageOffsetZ);
    scene.add(rightWall);

    const rightWallShape = new CANNON.Box(new CANNON.Vec3(0.1, barrierHalfHeight, LANE_LENGTH / 2));
    const rightWallBody = new CANNON.Body({ mass: 0, shape: rightWallShape, material: physicsMaterial });
    rightWallBody.position.set(rightWall.position.x, barrierHalfHeight, stageOffsetZ);
    world.addBody(rightWallBody);

    const backWallGeo = new THREE.BoxGeometry(LANE_WIDTH + 0.4, WALL_HEIGHT, 0.2);
    const backWall = new THREE.Mesh(backWallGeo, wallMat);
    backWall.position.set(0, WALL_HEIGHT / 2, -LANE_LENGTH / 2 + stageOffsetZ);
    scene.add(backWall);

    const backWallShape = new CANNON.Box(new CANNON.Vec3((LANE_WIDTH + 0.4) / 2, barrierHalfHeight, 0.1));
    const backWallBody = new CANNON.Body({ mass: 0, shape: backWallShape, material: physicsMaterial });
    backWallBody.position.set(0, barrierHalfHeight, -LANE_LENGTH / 2 + stageOffsetZ);
    world.addBody(backWallBody);
}

/**
 * æ–°ã—ã„ã‚­ãƒ¥ãƒ¼ãƒ–ã‚’ç”Ÿæˆã™ã‚‹
 */
function spawnPlayerCube() {
    if (isGameOver) return; 

    const numbers = [];
    let num = currentMinSpawn;
    for (let i = 0; i < 5; i++) {
        numbers.push(num);
        num = getNextNumber(num);
    }
    
    const spawnNum = numbers[Math.floor(Math.random() * numbers.length)];
    const color = getCubeColor(spawnNum);

    playerCube = createNumberCube(spawnNum, color);
    playerCube.position.set(0, CUBE_SIZE / 2, 1.5);
    scene.add(playerCube);

    currentPlayerCubeType = 'normal';
    isShooting = false;
}

/**
 * 3Dã‚­ãƒ¥ãƒ¼ãƒ–ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç”Ÿæˆã™ã‚‹ (é€šå¸¸)
 */
function createNumberCube(number, color) {
    const group = new THREE.Group();
    group.userData = { number: number, isMagical: false, isBomb: false };

    const geometry = new THREE.BoxGeometry(CUBE_SIZE, CUBE_SIZE, CUBE_SIZE);
    const material = new THREE.MeshPhongMaterial({ color: color });
    const mesh = new THREE.Mesh(geometry, material);
    mesh.castShadow = true;
    group.add(mesh);

    const canvas = document.createElement('canvas');
    canvas.width = 128; canvas.height = 128;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = color;
    ctx.fillRect(0, 0, 128, 128);
    ctx.fillStyle = 'white';
    
    const displayText = formatNumber(number);
    let fontSize = 75;
    if (displayText.length >= 4) {
        fontSize = 50;
    } else if (displayText.length === 3) {
        fontSize = 60;
    } else if (displayText.length === 2) {
        fontSize = 65;
    }
    
    ctx.font = `Bold ${fontSize}px Arial`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(displayText, 64, 64);

    const texture = new THREE.CanvasTexture(canvas);
    const textMat = new THREE.MeshBasicMaterial({ map: texture, transparent: true });
    const textGeom = new THREE.PlaneGeometry(0.9, 0.9);

    const offsets = [
        { pos: [0, 0, 0.51], rot: [0, 0, 0] },
        { pos: [0, 0, -0.51], rot: [0, Math.PI, 0] },
        { pos: [0, 0.51, 0], rot: [-Math.PI / 2, 0, 0] },
        { pos: [0, -0.51, 0], rot: [Math.PI / 2, 0, 0] }, 
        { pos: [0.51, 0, 0], rot: [0, Math.PI / 2, 0] },
        { pos: [-0.51, 0, 0], rot: [0, -Math.PI / 2, 0] }
    ];

    offsets.forEach(o => {
        const p = new THREE.Mesh(textGeom, textMat);
        p.position.set(...o.pos);
        p.rotation.set(...o.rot);
        group.add(p);
    });

    return group;
}

/**
 * ãƒã‚¸ã‚«ãƒ«ã‚­ãƒ¥ãƒ¼ãƒ–ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç”Ÿæˆã™ã‚‹
 */
function createMagicalCube() {
    const group = new THREE.Group();
    group.userData = { number: -1, isMagical: true, isBomb: false };

    const geometry = new THREE.BoxGeometry(CUBE_SIZE, CUBE_SIZE, CUBE_SIZE);
    
    // Canvasã‚’ç”¨ã„ã¦1é¢ã‚’4è‰²ã«å¡—ã‚Šåˆ†ã‘ãŸãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’ç”Ÿæˆã™ã‚‹
    const canvas = document.createElement('canvas');
    canvas.width = 128; 
    canvas.height = 128;
    const ctx = canvas.getContext('2d');
    
    // å·¦ä¸Š: èµ¤
    ctx.fillStyle = '#ff3333';
    ctx.fillRect(0, 0, 64, 64);
    // å³ä¸Š: é’
    ctx.fillStyle = '#33ccff';
    ctx.fillRect(64, 0, 64, 64);
    // å·¦ä¸‹: ç·‘
    ctx.fillStyle = '#66ff33';
    ctx.fillRect(0, 64, 64, 64);
    // å³ä¸‹: é»„è‰²
    ctx.fillStyle = '#ffcc00';
    ctx.fillRect(64, 64, 64, 64);

    // ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‹ã‚‰ãƒãƒ†ãƒªã‚¢ãƒ«ã‚’ä½œæˆã—ã€ã‚­ãƒ¥ãƒ¼ãƒ–å…¨ä½“ã«é©ç”¨
    const texture = new THREE.CanvasTexture(canvas);
    const material = new THREE.MeshPhongMaterial({ map: texture });
    
    const mesh = new THREE.Mesh(geometry, material);
    mesh.castShadow = true;
    group.add(mesh);
    
    return group;
}

/**
 * ãƒœãƒ ã‚­ãƒ¥ãƒ¼ãƒ–ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç”Ÿæˆã™ã‚‹
 */
function createBombCube() {
    const group = new THREE.Group();
    group.userData = { number: -1, isMagical: false, isBomb: true };

    const geometry = new THREE.BoxGeometry(CUBE_SIZE, CUBE_SIZE, CUBE_SIZE);
    const material = new THREE.MeshPhongMaterial({ color: 0x222222 }); 
    const mesh = new THREE.Mesh(geometry, material);
    mesh.castShadow = true;
    group.add(mesh);
    return group;
}

/**
 * ã‚¢ã‚¤ãƒ†ãƒ ã®UIçŠ¶æ…‹ã‚’æ›´æ–°ã™ã‚‹
 */
function updateItemUI() {
    document.getElementById('count-magical').innerText = magicalCubeCount;
    document.getElementById('count-bomb').innerText = bombCubeCount;

    const btnMagical = document.getElementById('btn-magical');
    const btnBomb = document.getElementById('btn-bomb');

    if (magicalCubeCount <= 0) btnMagical.classList.add('disabled');
    else btnMagical.classList.remove('disabled');

    if (bombCubeCount <= 0) btnBomb.classList.add('disabled');
    else btnBomb.classList.remove('disabled');
}

/**
 * ã‚­ãƒ¥ãƒ¼ãƒ–ã‚’ç™ºå°„ã™ã‚‹å‡¦ç†
 */
function shootCube() {
    if (!playerCube || isShooting || isGameOver || isMilestonePaused) return;

    const isOverLine = physicsObjects.some(obj => obj.body.position.z > DEAD_LINE_Z);
    if (isOverLine) return;

    isShooting = true;

    // å°„å‡ºéŸ³ã®å†ç”Ÿ
    playSound('shoot');

    // ç™ºå°„æ™‚ã«ã‚¢ã‚¤ãƒ†ãƒ ã‚’æ¶ˆè²»ã™ã‚‹
    if (currentPlayerCubeType === 'magical') {
        magicalCubeCount--;
    } else if (currentPlayerCubeType === 'bomb') {
        bombCubeCount--;
    }
    updateItemUI();

    const shape = new CANNON.Box(new CANNON.Vec3(CUBE_SIZE / 2, CUBE_SIZE / 2, CUBE_SIZE / 2));
    const body = new CANNON.Body({ mass: 1, shape: shape, material: physicsMaterial });
    
    body.userData = { 
        isCube: true, 
        number: playerCube.userData.number, 
        isMagical: playerCube.userData.isMagical || false,
        isBomb: playerCube.userData.isBomb || false,
        isMerging: false 
    };

    body.addEventListener('collide', handleCollision);
    body.linearDamping = 0.4;
    body.angularDamping = 0.4;
    body.position.copy(playerCube.position);
    body.quaternion.copy(playerCube.quaternion);
    body.velocity.set(0, 0, CUBE_SPEED);
    body.angularVelocity.set(0, 0, 0);

    world.addBody(body);
    physicsObjects.push({ mesh: playerCube, body: body });

    playerCube = null;
    needsSave = true; 

    setTimeout(() => {
        spawnPlayerCube();
    }, 500);
}

/**
 * ã‚­ãƒ¥ãƒ¼ãƒ–åŒå£«ã®è¡çªåˆ¤å®š
 */
function handleCollision(e) {
    const bodyA = e.target;
    const bodyB = e.body;

    if (bodyA.userData && bodyB.userData && bodyA.userData.isCube && bodyB.userData.isCube) {
        if (bodyA.userData.isMerging || bodyB.userData.isMerging) return;

        // ãƒœãƒ ã‚­ãƒ¥ãƒ¼ãƒ–ã®è¡çª
        if (bodyA.userData.isBomb || bodyB.userData.isBomb) {
            bodyA.userData.isMerging = true;
            bodyB.userData.isMerging = true;
            bombQueue.push({ bodyA, bodyB });
            return;
        }

        // ãƒã‚¸ã‚«ãƒ«ã‚­ãƒ¥ãƒ¼ãƒ–ã®è¡çª
        if (bodyA.userData.isMagical || bodyB.userData.isMagical) {
            if (bodyA.userData.isMagical && bodyB.userData.isMagical) return;
            bodyA.userData.isMerging = true;
            bodyB.userData.isMerging = true;
            mergeQueue.push({ bodyA, bodyB, isMagicalMerge: true });
            return;
        }

        // é€šå¸¸ã‚­ãƒ¥ãƒ¼ãƒ–ã®è¡çª
        if (bodyA.userData.number === bodyB.userData.number) {
            bodyA.userData.isMerging = true;
            bodyB.userData.isMerging = true;
            mergeQueue.push({ bodyA, bodyB, isMagicalMerge: false });
        }
    }
}

/**
 * çˆ†ç™ºå¾…ã¡ã®ã‚­ãƒ¥ãƒ¼ã‚’å‡¦ç†ã™ã‚‹
 */
function processBombQueue() {
    while (bombQueue.length > 0) {
        const { bodyA, bodyB } = bombQueue.shift();
        if (!world.bodies.includes(bodyA) || !world.bodies.includes(bodyB)) continue;

        const bombBody = bodyA.userData.isBomb ? bodyA : bodyB;
        const explosionPos = new CANNON.Vec3().copy(bombBody.position);

        // çˆ†ç™ºéŸ³ã®å†ç”Ÿ
        playSound('bomb');
        // çˆ†ç™ºã®ã‚­ãƒ©ã‚­ãƒ©æ¼”å‡º
        createMergeParticles(new THREE.Vector3(explosionPos.x, explosionPos.y, explosionPos.z), '#ff5500', 35);

        removeCube(bodyA);
        removeCube(bodyB);
        needsSave = true; 

        // å‘¨å›²ã«å¼·ã„è¡æ’ƒæ³¢ã‚’ç™ºç”Ÿã•ã›ã‚‹
        const shockwaveRadius = 5.0;
        const shockwaveForce = 12;

        for (const obj of physicsObjects) {
            const otherBody = obj.body;
            const dist = explosionPos.distanceTo(otherBody.position);
            if (dist < shockwaveRadius) {
                const dir = new CANNON.Vec3();
                otherBody.position.vsub(explosionPos, dir);
                const force = shockwaveForce * (1 - dist / shockwaveRadius);
                dir.normalize();
                dir.scale(force, dir);
                dir.y += force * 0.8;
                otherBody.applyImpulse(dir, new CANNON.Vec3(0, 0, 0));
            }
        }
    }
}

/**
 * åˆä½“å¾…ã¡ã®ã‚­ãƒ¥ãƒ¼ã‚’å‡¦ç†ã—ã€ãƒã‚¤ãƒ«ã‚¹ãƒˆãƒ¼ãƒ³ã‚„ã‚¢ã‚¤ãƒ†ãƒ ç²å¾—ã®ãƒã‚§ãƒƒã‚¯ã‚’è¡Œã†
 */
function processMergeQueue() {
    let reachedMilestone = false;
    let displayMilestoneNum = 0n;

    while (mergeQueue.length > 0) {
        const { bodyA, bodyB, isMagicalMerge } = mergeQueue.shift();

        if (!world.bodies.includes(bodyA) || !world.bodies.includes(bodyB)) continue;

        let frontBody, backBody;
        if (bodyA.position.z > bodyB.position.z) {
            frontBody = bodyA;
            backBody = bodyB;
        } else {
            frontBody = bodyB;
            backBody = bodyA;
        }

        let oldNumber;
        if (isMagicalMerge) {
            let magicalBody = bodyA.userData.isMagical ? bodyA : bodyB;
            let targetBody = bodyA.userData.isMagical ? bodyB : bodyA;
            oldNumber = targetBody.userData.number;
            frontBody = magicalBody;
            backBody = targetBody;
        } else {
            oldNumber = backBody.userData.number;
        }

        const newNumber = getNextNumber(oldNumber);
        
        // ãƒãƒ¼ã‚¸éŸ³ã¨æ¼”å‡ºã®å®Ÿè¡Œ
        playSound('merge');
        createMergeParticles(new THREE.Vector3().copy(backBody.position), getCubeColor(newNumber), 20);

        score += newNumber;
        updateScoreUI();  
        needsSave = true; 

        removeCube(frontBody);
        updateCubeToNewNumber(backBody, newNumber);
        applyMergeEffects(backBody, newNumber);

        // ã‚¢ã‚¤ãƒ†ãƒ ç²å¾—ã®åˆ¤å®š
        const itemThreshold = currentMinSpawn * 512n;
        if (newNumber >= itemThreshold) {
            if (Math.random() < 0.5) magicalCubeCount++;
            else bombCubeCount++;
            updateItemUI();
        }

        while (newNumber >= nextMilestone) {
            reachedMilestone = true;
            displayMilestoneNum = nextMilestone;
            
            const oldMin = currentMinSpawn;
            currentMinSpawn = getNextNumber(currentMinSpawn);
            nextMilestone = getNextNumber(nextMilestone);
            
            for (const obj of physicsObjects) {
                if (obj.body.userData.number === oldMin && !obj.body.userData.isMagical && !obj.body.userData.isBomb) {
                    updateCubeToNewNumber(obj.body, currentMinSpawn);
                }
            }
            if (playerCube && playerCube.userData.number === oldMin && currentPlayerCubeType === 'normal') {
                const currentPosX = playerCube.position.x;
                const currentPosZ = playerCube.position.z;
                scene.remove(playerCube);
                const color = getCubeColor(currentMinSpawn);
                playerCube = createNumberCube(currentMinSpawn, color);
                playerCube.position.set(currentPosX, CUBE_SIZE / 2, currentPosZ);
                scene.add(playerCube);
            }
        }
    }

    if (reachedMilestone) {
        triggerMilestoneUI(displayMilestoneNum);
    }
}

/**
 * åˆä½“æ™‚ã®æ¼”å‡º
 */
function applyMergeEffects(newBody, newNumber) {
    const mergePos = newBody.position;
    newBody.velocity.set(0, 0, 0);
    newBody.angularVelocity.set(0, 0, 0);

    const MAX_HORIZONTAL_DIST = CUBE_SIZE * 3;
    const POPUP_IMPULSE_Y = 8.5;
    const gravity = Math.abs(world.gravity.y);
    const flightTime = (2 * POPUP_IMPULSE_Y) / gravity;

    let targetBody = null;
    let minDistance = Infinity;
    const searchRadius = 6.0;

    for (const obj of physicsObjects) {
        const otherBody = obj.body;
        if (otherBody === newBody) continue;
        if (otherBody.userData && otherBody.userData.isCube && otherBody.userData.number === newNumber) {
            const dist = mergePos.distanceTo(otherBody.position);
            if (dist < searchRadius && dist < minDistance) {
                minDistance = dist;
                targetBody = otherBody;
            }
        }
    }

    const impulseVec = new CANNON.Vec3(0, POPUP_IMPULSE_Y, 0);
    if (targetBody) {
        const dir = new CANNON.Vec3();
        targetBody.position.vsub(mergePos, dir);
        dir.y = 0;
        const actualDist = dir.length();
        const jumpDist = Math.min(actualDist, MAX_HORIZONTAL_DIST);
        const horizontalVelocity = jumpDist / flightTime;
        dir.normalize();
        impulseVec.x = dir.x * horizontalVelocity;
        impulseVec.z = dir.z * horizontalVelocity;
        const dampingComp = 1.25; 
        impulseVec.x *= dampingComp;
        impulseVec.z *= dampingComp;
    } else {
        impulseVec.z = -1.5;
    }

    newBody.applyImpulse(impulseVec, new CANNON.Vec3(0, 0, 0));

    const shockwaveRadius = 2.5;
    const shockwaveForce = 4;

    for (const obj of physicsObjects) {
        const otherBody = obj.body;
        if (otherBody === newBody) continue;
        const dist = mergePos.distanceTo(otherBody.position);
        if (dist < shockwaveRadius) {
            const dir = new CANNON.Vec3();
            otherBody.position.vsub(mergePos, dir);
            const force = shockwaveForce * (1 - dist / shockwaveRadius);
            dir.normalize();
            dir.scale(force, dir);
            dir.y += force * 0.5;
            otherBody.applyImpulse(dir, new CANNON.Vec3(0, 0, 0));
        }
    }
}

/**
 * ã‚­ãƒ¥ãƒ¼ãƒ–ã®å‰Šé™¤
 */
function removeCube(body) {
    const index = physicsObjects.findIndex(obj => obj.body === body);
    if (index !== -1) {
        const obj = physicsObjects[index];
        scene.remove(obj.mesh);
        world.removeBody(body);
        physicsObjects.splice(index, 1);
    }
}

/**
 * ã‚­ãƒ¥ãƒ¼ãƒ–ã®æ•°å€¤ã‚’æ›´æ–°
 */
function updateCubeToNewNumber(body, newNumber) {
    const index = physicsObjects.findIndex(obj => obj.body === body);
    if (index !== -1) {
        const obj = physicsObjects[index];
        scene.remove(obj.mesh);
        const color = getCubeColor(newNumber); 
        const newMesh = createNumberCube(newNumber, color);
        newMesh.position.copy(body.position);
        newMesh.quaternion.copy(body.quaternion);
        scene.add(newMesh);
        obj.mesh = newMesh;
        body.userData.number = newNumber;
        body.userData.isMerging = false; 
    }
}

/**
 * UIã®ã‚¹ã‚³ã‚¢è¡¨ç¤ºã‚’æ›´æ–°
 */
function updateScoreUI() {
    if (score > highScore) {
        highScore = score;
        localStorage.setItem('chainCubeHighScore', highScore.toString());
    }
    document.getElementById('score').innerText = 'ã‚¹ã‚³ã‚¢ï¼š' + score;
    document.getElementById('best-score').innerText = 'ãƒ™ã‚¹ãƒˆï¼š' + highScore;
}

/**
 * ãƒã‚¤ãƒ«ã‚¹ãƒˆãƒ¼ãƒ³(ç¥ç¦)ç”»é¢ã®è¡¨ç¤º
 */
function triggerMilestoneUI(milestoneNum) {
    isMilestonePaused = true;
    document.getElementById('milestone-number').innerText = formatNumber(milestoneNum);
    document.getElementById('milestone-overlay').style.display = 'flex';
}

/**
 * ãƒã‚¤ãƒ«ã‚¹ãƒˆãƒ¼ãƒ³ç”»é¢ã‹ã‚‰ã®å¾©å¸°
 */
window.resumeFromMilestone = function() {
    if (!isMilestonePaused) return; 
    initAudio(); // æ“ä½œã«å¿œã˜ã¦ã‚µã‚¦ãƒ³ãƒ‰æœ‰åŠ¹åŒ–
    isMilestonePaused = false;
    document.getElementById('milestone-overlay').style.display = 'none';
    needsSave = true; 
}

/**
 * ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ç”»é¢ã®è¡¨ç¤º
 */
function triggerGameOver() {
    isGameOver = true;
    document.getElementById('final-score').innerText = score;
    document.getElementById('game-over-overlay').style.display = 'flex';
    if (playerCube) {
        scene.remove(playerCube);
        playerCube = null;
    }
}

/**
 * ã‚²ãƒ¼ãƒ ã‚’åˆæœŸçŠ¶æ…‹ã«ãƒªã‚»ãƒƒãƒˆã™ã‚‹
 */
window.resetGame = function() {
    initAudio();
    for (let i = physicsObjects.length - 1; i >= 0; i--) {
        const obj = physicsObjects[i];
        scene.remove(obj.mesh);
        world.removeBody(obj.body);
    }
    physicsObjects = [];

    if (playerCube) {
        scene.remove(playerCube);
        playerCube = null;
    }

    score = 0n;
    isGameOver = false;
    updateScoreUI();

    document.getElementById('game-over-overlay').style.display = 'none';

    currentMinSpawn = 2n;
    nextMilestone = 1000n;
    isMilestonePaused = false;
    document.getElementById('milestone-overlay').style.display = 'none';

    magicalCubeCount = 1;
    bombCubeCount = 1;
    updateItemUI();

    mergeQueue.length = 0;
    bombQueue.length = 0;
    isShooting = false;
    needsSave = false;
    localStorage.removeItem('chainCubeGameState');
    spawnPlayerCube();
}

/**
 * ãƒªã‚»ãƒƒãƒˆæ“ä½œã®ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
 */
window.handleReset = function() {
    initAudio();
    if (isGameOver || confirm('ãƒªã‚»ãƒƒãƒˆã—ã¾ã™ã‹ï¼Ÿ')) {
        resetGame();
    }
}

/**
 * ãƒã‚¸ã‚«ãƒ«ã‚­ãƒ¥ãƒ¼ãƒ–ã‚’è£…å‚™ã™ã‚‹
 */
window.equipMagical = function() {
    initAudio();
    if (magicalCubeCount <= 0 || isShooting || isGameOver || isMilestonePaused) return;
    if (currentPlayerCubeType === 'magical') return; 
    
    const currentPosX = playerCube ? playerCube.position.x : 0;
    const currentPosZ = playerCube ? playerCube.position.z : 1.5;
    if (playerCube) scene.remove(playerCube);
    
    playerCube = createMagicalCube();
    playerCube.position.set(currentPosX, CUBE_SIZE / 2, currentPosZ);
    scene.add(playerCube);
    currentPlayerCubeType = 'magical';
};

/**
 * ãƒœãƒ ã‚­ãƒ¥ãƒ¼ãƒ–ã‚’è£…å‚™ã™ã‚‹
 */
window.equipBomb = function() {
    initAudio();
    if (bombCubeCount <= 0 || isShooting || isGameOver || isMilestonePaused) return;
    if (currentPlayerCubeType === 'bomb') return;
    
    const currentPosX = playerCube ? playerCube.position.x : 0;
    const currentPosZ = playerCube ? playerCube.position.z : 1.5;
    if (playerCube) scene.remove(playerCube);
    
    playerCube = createBombCube();
    playerCube.position.set(currentPosX, CUBE_SIZE / 2, currentPosZ);
    scene.add(playerCube);
    currentPlayerCubeType = 'bomb';
};

/**
 * ã‚²ãƒ¼ãƒ çŠ¶æ…‹ã‚’ä¿å­˜
 */
function saveGameState() {
    if (isGameOver) return; 

    const cubesData = physicsObjects.map(obj => ({
        x: obj.body.position.x, y: obj.body.position.y, z: obj.body.position.z,
        qx: obj.body.quaternion.x, qy: obj.body.quaternion.y, qz: obj.body.quaternion.z, qw: obj.body.quaternion.w,
        value: obj.body.userData.number.toString(),
        isMagical: obj.body.userData.isMagical || false,
        isBomb: obj.body.userData.isBomb || false,
        vx: obj.body.velocity.x, vy: obj.body.velocity.y, vz: obj.body.velocity.z,
        wx: obj.body.angularVelocity.x, wy: obj.body.angularVelocity.y, wz: obj.body.angularVelocity.z
    }));

    const state = {
        highScore: highScore.toString(),
        currentScore: score.toString(),
        currentMinSpawn: currentMinSpawn.toString(),
        nextMilestone: nextMilestone.toString(),
        magicalCubeCount: magicalCubeCount,
        bombCubeCount: bombCubeCount,
        cubes: cubesData
    };
    localStorage.setItem('chainCubeGameState', JSON.stringify(state));
}

/**
 * ã‚²ãƒ¼ãƒ çŠ¶æ…‹ã‚’èª­ã¿è¾¼ã¿
 */
function loadGameState() {
    const savedData = localStorage.getItem('chainCubeGameState');
    if (savedData) {
        try {
            const state = JSON.parse(savedData);
            score = BigInt(state.currentScore || "0");
            highScore = BigInt(state.highScore || "0");
            
            currentMinSpawn = BigInt(state.currentMinSpawn || "2");
            nextMilestone = BigInt(state.nextMilestone || "1000");

            magicalCubeCount = state.magicalCubeCount !== undefined ? state.magicalCubeCount : 1;
            bombCubeCount = state.bombCubeCount !== undefined ? state.bombCubeCount : 1;
            
            updateScoreUI();

            state.cubes.forEach(cubeData => {
                const num = BigInt(cubeData.value);
                let mesh;
                if (cubeData.isMagical) {
                    mesh = createMagicalCube();
                } else if (cubeData.isBomb) {
                    mesh = createBombCube();
                } else {
                    const color = getCubeColor(num);
                    mesh = createNumberCube(num, color);
                }
                
                mesh.position.set(cubeData.x, cubeData.y, cubeData.z);
                mesh.quaternion.set(cubeData.qx, cubeData.qy, cubeData.qz, cubeData.qw);
                scene.add(mesh);

                const shape = new CANNON.Box(new CANNON.Vec3(CUBE_SIZE / 2, CUBE_SIZE / 2, CUBE_SIZE / 2));
                const body = new CANNON.Body({ mass: 1, shape: shape, material: physicsMaterial });
                body.userData = { 
                    isCube: true, number: num, isMerging: false, 
                    isMagical: cubeData.isMagical || false, isBomb: cubeData.isBomb || false 
                };
                body.addEventListener('collide', handleCollision);
                body.linearDamping = 0.4;
                body.angularDamping = 0.4;
                body.position.set(cubeData.x, cubeData.y, cubeData.z);
                body.quaternion.set(cubeData.qx, cubeData.qy, cubeData.qz, cubeData.qw);
                
                if (cubeData.vx !== undefined) {
                    body.velocity.set(cubeData.vx, cubeData.vy, cubeData.vz);
                    body.angularVelocity.set(cubeData.wx, cubeData.wy, cubeData.wz);
                }
                world.addBody(body);
                physicsObjects.push({ mesh: mesh, body: body });
            });
            return true;
        } catch (e) {
            console.error("Failed to load game state", e);
            return false;
        }
    }
    return false;
}

/**
 * ã‚­ãƒ¼å…¥åŠ›ã®åˆ¶å¾¡
 */
function handleKey(e, isDown) {
    initAudio(); // ãƒ–ãƒ©ã‚¦ã‚¶åˆ¶ç´„ã®ãŸã‚ã‚­ãƒ¼å…¥åŠ›æ™‚ã«ã‚‚AudioContextåˆæœŸåŒ–
    if (isGameOver && isDown && e.key.toLowerCase() !== 'r') return;

    const key = e.key.toLowerCase();
    
    if (isMilestonePaused) {
        if (isDown && (e.key === 'Enter' || e.key === ' ' || key === 'z')) {
            window.resumeFromMilestone();
        }
        return; 
    }

    if (isDown && key === 'r') handleReset();
    if (isDown && key === 'x') equipMagical();
    if (isDown && key === 'c') equipBomb();

    if (e.key === 'ArrowLeft' || key === 'a') moveLeft = isDown;
    if (e.key === 'ArrowRight' || key === 'd') moveRight = isDown;
    if (isDown && (e.key === 'Enter' || e.key === ' ' || key === 'z')) shootCube();

    if (isDown && playerCube) {
        if (key === 'w' || e.key === 'ArrowUp' || key === 's' || e.key === 'ArrowDown') {
            const currentPosX = playerCube.position.x;
            const currentPosZ = playerCube.position.z;

            if (currentPlayerCubeType !== 'normal') {
                currentPlayerCubeType = 'normal';
                scene.remove(playerCube);
                const color = getCubeColor(currentMinSpawn);
                playerCube = createNumberCube(currentMinSpawn, color);
                playerCube.position.set(currentPosX, CUBE_SIZE / 2, currentPosZ);
                scene.add(playerCube);
            } else {
                const currentNum = playerCube.userData.number;
                let nextNum = currentNum;
                if (key === 'w' || e.key === 'ArrowUp') {
                    const prev = getPrevNumber(currentNum);
                    nextNum = prev < currentMinSpawn ? currentMinSpawn : prev;
                }
                if (key === 's' || e.key === 'ArrowDown') nextNum = getNextNumber(currentNum);

                if (nextNum !== currentNum) {
                    scene.remove(playerCube);
                    const color = getCubeColor(nextNum);
                    playerCube = createNumberCube(nextNum, color);
                    playerCube.position.set(currentPosX, CUBE_SIZE / 2, currentPosZ);
                    scene.add(playerCube);
                }
            }
        }
    }
}

/**
 * ãƒã‚¦ã‚¹ãƒ»ã‚¿ãƒƒãƒç§»å‹•æ™‚ã®å‡¦ç†
 */
function onPointerMove(event) {
    if (!playerCube || isGameOver || isShooting || isMilestonePaused) return;

    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

    raycaster.setFromCamera(mouse, camera);
    const intersectPoint = new THREE.Vector3();
    raycaster.ray.intersectPlane(dragPlane, intersectPoint);

    if (intersectPoint) {
        const limit = (LANE_WIDTH / 2) - (CUBE_SIZE / 2) - SIDE_MARGIN;
        playerCube.position.x = Math.max(-limit, Math.min(limit, intersectPoint.x));
    }
}

/**
 * ãƒã‚¦ã‚¹ãƒ»ã‚¿ãƒƒãƒã§ã®æ“ä½œé–‹å§‹ï¼ˆç”»é¢ã«è§¦ã‚ŒãŸ/ã‚¯ãƒªãƒƒã‚¯ã—ãŸï¼‰æ™‚ã®å‡¦ç†
 */
function onPointerDown(event) {
    initAudio(); 
    if (event.target.closest('.item-btn') || event.target.closest('.reset-button')) return;

    if (isMilestonePaused) return;

    if (!playerCube || isGameOver || isShooting) return;

    // ã‚¿ãƒƒãƒãƒ‡ãƒã‚¤ã‚¹ï¼ˆã‚¹ãƒãƒ›ç­‰ï¼‰ã®å ´åˆã¯ãƒ‰ãƒ©ãƒƒã‚°ã§ç§»å‹•ã™ã‚‹ãŸã‚ã€ã‚¿ãƒƒãƒé–‹å§‹ä½ç½®ã«ã‚­ãƒ¥ãƒ¼ãƒ–ã‚’ç§»å‹•ã•ã›ã‚‹ã®ã¿ã§å°„å‡ºã¯è¡Œã‚ãªã„
    if (event.pointerType !== 'mouse') {
        onPointerMove(event);
        return;
    }

    // ãƒã‚¦ã‚¹æ“ä½œï¼ˆPCï¼‰ã®å ´åˆã¯å¾“æ¥ã®æŒ™å‹•é€šã‚Šã€ã‚¯ãƒªãƒƒã‚¯ã§å³å°„å‡ºã™ã‚‹
    shootCube();
}

/**
 * ãƒã‚¦ã‚¹ãƒ»ã‚¿ãƒƒãƒã§ã®æ“ä½œçµ‚äº†ï¼ˆæŒ‡ã‚’é›¢ã—ãŸ/ã‚¯ãƒªãƒƒã‚¯ã‚’é›¢ã—ãŸï¼‰æ™‚ã®å‡¦ç†
 */
function onPointerUp(event) {
    // ãƒã‚¦ã‚¹æ“ä½œã®å ´åˆã¯ pointerdown ã§æ—¢ã«å°„å‡ºã•ã‚Œã¦ã„ã‚‹ãŸã‚ä½•ã‚‚ã—ãªã„
    if (event.pointerType === 'mouse') return;

    if (event.target.closest('.item-btn') || event.target.closest('.reset-button')) return;

    if (isMilestonePaused) return;

    if (!playerCube || isGameOver || isShooting) return;

    // ã‚¿ãƒƒãƒãƒ‡ãƒã‚¤ã‚¹ã®å ´åˆã¯æŒ‡ã‚’é›¢ã—ãŸã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§å°„å‡ºã™ã‚‹
    shootCube();
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

/**
 * ãƒ¡ã‚¤ãƒ³ãƒ«ãƒ¼ãƒ—
 */
function animate() {
    requestAnimationFrame(animate);

    if (!isMilestonePaused) {
        world.step(1 / 60);
        processMergeQueue();
        processBombQueue();
        
        // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®æ›´æ–°
        updateParticles();

        if (needsSave && !isGameOver) {
            let allSleeping = true;
            for (const obj of physicsObjects) {
                const v = obj.body.velocity.lengthSquared();
                const w = obj.body.angularVelocity.lengthSquared();
                if (v > 0.05 || w > 0.05) {
                    allSleeping = false;
                    break;
                }
            }

            if (allSleeping) {
                let isOut = false;
                for (const obj of physicsObjects) {
                    if (obj.body.position.z > DEAD_LINE_Z) {
                        isOut = true;
                        break;
                    }
                }

                if (isOut) {
                    triggerGameOver();
                } else {
                    saveGameState();
                }
                needsSave = false;
            }
        }

        const limit = (LANE_WIDTH / 2) - (CUBE_SIZE / 2) - SIDE_MARGIN;
        if (playerCube && !isGameOver) {
            if (moveLeft) playerCube.position.x -= moveSpeed;
            if (moveRight) playerCube.position.x += moveSpeed;
            playerCube.position.x = Math.max(-limit, Math.min(limit, playerCube.position.x));
        }
    }

    for (const obj of physicsObjects) {
        obj.mesh.position.copy(obj.body.position);
        obj.mesh.quaternion.copy(obj.body.quaternion);
    }

    renderer.render(scene, camera);
}
</script>
</body>
</html>