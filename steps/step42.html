<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chain Cube</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #abeaff; font-family: 'Arial', sans-serif; }
        canvas { display: block; }

        #top-ui {
            position: absolute;
            top: 20px;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 0 20px;
            box-sizing: border-box;
            pointer-events: none;
        }

        .score-container {
            background: rgba(255, 255, 255, 0.8);
            padding: 5px 20px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 4px 0 rgba(0,0,0,0.1);
        }

        .best-label { font-size: 12px; color: #f57c00; font-weight: bold; }
        .score-value { font-size: 24px; font-weight: bold; color: #333; }

        #bottom-ui {
            position: absolute;
            bottom: 40px;
            width: 100%;
            display: flex;
            justify-content: center;
            gap: 30px;
            pointer-events: none;
        }

        .item-btn {
            width: 70px;
            height: 70px;
            background: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 6px 0 #ddd;
            font-size: 30px;
            position: relative;
        }

        .item-count {
            position: absolute;
            bottom: -5px;
            left: -5px;
            background: #ffb74d;
            color: white;
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 10px;
            font-weight: bold;
        }

        .instruction {
            position: absolute;
            bottom: 70px;
            width: 100%;
            text-align: center;
            color: #555;
            font-size: 18px;
            font-weight: bold;
            pointer-events: none;
        }
    </style>
</head>
<body>

<div id="top-ui">
    <div style="width: 50px;"></div>
    <div class="score-container">
        <div class="score-value" id="score">スコア：0</div>
    </div>
    <div style="width: 50px;"></div>
</div>

<div class="instruction">左右キー または A / D キーで移動<br>Enter キーで発射</div>

<div id="bottom-ui">

</div>

<script type="importmap">
{
    "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js"
    }
}
</script>

<script type="module">
import * as THREE from 'three';
import * as CANNON from 'cannon-es';

const CUBE_SIZE = 1;
const LANE_WIDTH = 4.5;
const LANE_LENGTH = 10;
const WALL_HEIGHT = 1.2;

/* 壁ぴったり防止マージン */
const SIDE_MARGIN = 0.05;

let scene, camera, renderer, playerCube;
let moveLeft = false, moveRight = false;
const moveSpeed = 0.1;

// --- 物理演算用・ゲームロジック用変数 ---
let world;
let physicsMaterial;
let physicsObjects = [];
let isShooting = false;
// スコアと衝突処理のキュー管理変数
let score = 0; 
const mergeQueue = [];

// 数字に応じた色定義
const cubeColors = {
    2: "#e53935",   // 赤
    4: "#fb8c00",   // オレンジ
    8: "#fbc02d",   // 黄
    16: "#43a047",  // 緑
    32: "#1e88e5",  // 青
    64: "#8e24aa",  // 紫
    128: "#e91e63", // ピンク
    256: "#00acc1", // シアン
    512: "#3949ab", // インディゴ
    1024: "#00897b",// ティール
    2048: "#d81b60",// ディープピンク
    4096: "#f4511e" // ディープオレンジ
};

init();
animate();

function init() {
    initPhysics();

    scene = new THREE.Scene();
    scene.background = new THREE.Color(0xabeaff);

    const aspect = window.innerWidth / window.innerHeight;
    camera = new THREE.PerspectiveCamera(40, aspect, 0.1, 1000);
    camera.position.set(0, 11, 12);
    camera.lookAt(0, -1, -2);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.9);
    scene.add(ambientLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
    dirLight.position.set(5, 15, 2);
    dirLight.castShadow = true;
    scene.add(dirLight);

    createStage();

    spawnPlayerCube();

    window.addEventListener('keydown', (e) => handleKey(e, true));
    window.addEventListener('keyup', (e) => handleKey(e, false));
    window.addEventListener('resize', onWindowResize);
}

function initPhysics() {
    world = new CANNON.World();
    // 重力を強めに設定し、浮き上がりを防止
    world.gravity.set(0, -10, 0); 

    // 全てのオブジェクトで共通して使うマテリアルと摩擦・反発設定
    physicsMaterial = new CANNON.Material('standard');
    const contactMaterial = new CANNON.ContactMaterial(physicsMaterial, physicsMaterial, {
        friction: 0.005,   // 摩擦係数 (床を滑るように小さく設定)
        restitution: 0.1  // 反発係数 (壁や床で跳ねないように小さく設定)
    });
    world.addContactMaterial(contactMaterial);
}

function createStage() {
    const stageOffsetZ = -2;

    // --- 床 ---
    const floorGeo = new THREE.PlaneGeometry(LANE_WIDTH, LANE_LENGTH);
    const floorMat = new THREE.MeshPhongMaterial({ color: 0xe8e8e8 });
    const floor = new THREE.Mesh(floorGeo, floorMat);
    floor.rotation.x = -Math.PI / 2;
    floor.position.z = stageOffsetZ;
    floor.receiveShadow = true;
    scene.add(floor);

    const floorShape = new CANNON.Plane();
    const floorBody = new CANNON.Body({ mass: 0, shape: floorShape, material: physicsMaterial });
    floorBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
    // Y=0 の平面として配置
    world.addBody(floorBody);

    // --- 白線 ---
    const lineMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 });
    for(let i = 0; i < 3; i++) {
        const dash = new THREE.Mesh(new THREE.PlaneGeometry(0.8, 0.15), lineMat);
        dash.rotation.x = -Math.PI / 2;
        dash.position.set((i - 1) * 1.4, 0.01, 1.5);
        scene.add(dash);
    }

    const wallMat = new THREE.MeshPhongMaterial({ color: 0xe6a15c });

    // --- 左壁 ---
    const sideWallGeo = new THREE.BoxGeometry(0.2, WALL_HEIGHT, LANE_LENGTH);
    const leftWall = new THREE.Mesh(sideWallGeo, wallMat);
    leftWall.position.set(-(LANE_WIDTH / 2 + 0.1), WALL_HEIGHT / 2, stageOffsetZ);
    scene.add(leftWall);
    
    const leftWallShape = new CANNON.Box(new CANNON.Vec3(0.1, WALL_HEIGHT / 2, LANE_LENGTH / 2));
    const leftWallBody = new CANNON.Body({ mass: 0, shape: leftWallShape, material: physicsMaterial });
    leftWallBody.position.copy(leftWall.position);
    world.addBody(leftWallBody);

    // --- 右壁 ---
    const rightWall = new THREE.Mesh(sideWallGeo, wallMat);
    rightWall.position.set(LANE_WIDTH / 2 + 0.1, WALL_HEIGHT / 2, stageOffsetZ);
    scene.add(rightWall);

    const rightWallShape = new CANNON.Box(new CANNON.Vec3(0.1, WALL_HEIGHT / 2, LANE_LENGTH / 2));
    const rightWallBody = new CANNON.Body({ mass: 0, shape: rightWallShape, material: physicsMaterial });
    rightWallBody.position.copy(rightWall.position);
    world.addBody(rightWallBody);

    // --- 奥壁 ---
    const backWallGeo = new THREE.BoxGeometry(LANE_WIDTH + 0.4, WALL_HEIGHT, 0.2);
    const backWall = new THREE.Mesh(backWallGeo, wallMat);
    backWall.position.set(0, WALL_HEIGHT / 2, -LANE_LENGTH / 2 + stageOffsetZ);
    scene.add(backWall);

    const backWallShape = new CANNON.Box(new CANNON.Vec3((LANE_WIDTH + 0.4) / 2, WALL_HEIGHT / 2, 0.1));
    const backWallBody = new CANNON.Body({ mass: 0, shape: backWallShape, material: physicsMaterial });
    backWallBody.position.copy(backWall.position);
    world.addBody(backWallBody);
}

function spawnPlayerCube() {
    // 2, 4, 8, 16, 32 からランダムに数字を選択
    const numbers = [2, 4, 8, 16, 32];
    const num = numbers[Math.floor(Math.random() * numbers.length)];
    const color = cubeColors[num];

    playerCube = createNumberCube(num, color);
    playerCube.position.set(0, CUBE_SIZE / 2, 3.5);
    scene.add(playerCube);

    isShooting = false;
}

function createNumberCube(number, color) {
    const group = new THREE.Group();
    // どの数字のキューブかを判定できるようにUserDataに保持させる
    group.userData.number = number; 

    const geometry = new THREE.BoxGeometry(CUBE_SIZE, CUBE_SIZE, CUBE_SIZE);
    const material = new THREE.MeshPhongMaterial({ color: color });
    const mesh = new THREE.Mesh(geometry, material);
    mesh.castShadow = true;
    group.add(mesh);

    const canvas = document.createElement('canvas');
    canvas.width = 128; canvas.height = 128;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = color;
    ctx.fillRect(0, 0, 128, 128);
    ctx.fillStyle = 'white';
    ctx.font = 'Bold 75px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(number, 64, 64);

    const texture = new THREE.CanvasTexture(canvas);
    const textMat = new THREE.MeshBasicMaterial({ map: texture, transparent: true });
    const textGeom = new THREE.PlaneGeometry(0.9, 0.9);

    const offsets = [
        { pos: [0, 0, 0.51], rot: [0, 0, 0] },
        { pos: [0, 0, -0.51], rot: [0, Math.PI, 0] },
        { pos: [0, 0.51, 0], rot: [-Math.PI / 2, 0, 0] },
        // ★修正箇所：下面の回転を Y軸回転(0, PI/2, 0) から X軸回転(PI/2, 0, 0) に変更
        // これによりテクスチャが水平になり、正しい向きで表示されるようになります。
        { pos: [0, -0.51, 0], rot: [Math.PI / 2, 0, 0] }, 
        { pos: [0.51, 0, 0], rot: [0, Math.PI / 2, 0] },
        { pos: [-0.51, 0, 0], rot: [0, -Math.PI / 2, 0] }
    ];

    offsets.forEach(o => {
        const p = new THREE.Mesh(textGeom, textMat);
        p.position.set(...o.pos);
        p.rotation.set(...o.rot);
        group.add(p);
    });

    return group;
}

function shootCube() {
    if (!playerCube || isShooting) return;
    isShooting = true;

    // 現在のキューブの物理ボディを作成
    const shape = new CANNON.Box(new CANNON.Vec3(CUBE_SIZE / 2, CUBE_SIZE / 2, CUBE_SIZE / 2));
    const body = new CANNON.Body({ mass: 1, shape: shape, material: physicsMaterial });
    
    // 物理ボディにもキューブの情報を持たせ、マージ処理の重複を防ぐフラグを設定する
    body.userData = { 
        isCube: true, 
        number: playerCube.userData.number, 
        isMerging: false 
    };

    // 衝突イベントのリスナーを登録
    body.addEventListener('collide', handleCollision);

    // 直線的な滑りを実現しつつ減速させる設定
    body.linearDamping = 0.4;
    body.angularDamping = 0.4;

    // 位置を同期
    body.position.copy(playerCube.position);
    body.quaternion.copy(playerCube.quaternion);

    // 奥方向へ直線的に射出 (回転させず、奥まで届くように速度を調整)
    body.velocity.set(0, 0, -25);
    body.angularVelocity.set(0, 0, 0);

    world.addBody(body);
    physicsObjects.push({ mesh: playerCube, body: body });

    // 操作対象から外す
    playerCube = null;

    // 0.5秒後に次弾装填
    setTimeout(() => {
        spawnPlayerCube();
    }, 500);
}

// 衝突イベントハンドラ
function handleCollision(e) {
    const bodyA = e.target; // 自身
    const bodyB = e.body;   // 衝突相手

    // 両方がキューブであり、同じ数字であるか判定
    if (bodyA.userData && bodyB.userData && bodyA.userData.isCube && bodyB.userData.isCube) {
        if (bodyA.userData.number === bodyB.userData.number) {
            // すでに他のマージ処理に巻き込まれている場合はスキップ
            if (bodyA.userData.isMerging || bodyB.userData.isMerging) return;
            
            // マージフラグを立てて、1回の衝突で複数回処理されるのを防ぐ
            bodyA.userData.isMerging = true;
            bodyB.userData.isMerging = true;
            
            // アニメーションループ内で安全に処理するため、キューに一時保存
            mergeQueue.push({ bodyA, bodyB });
        }
    }
}

// マージ処理の実行
function processMergeQueue() {
    while (mergeQueue.length > 0) {
        const { bodyA, bodyB } = mergeQueue.shift();

        // 他の処理で既に削除されていないか念のため確認
        if (!world.bodies.includes(bodyA) || !world.bodies.includes(bodyB)) {
            continue;
        }

        let frontBody, backBody;
        // Z座標が大きい方（手前側）と小さい方（奥側）を判定。カメラは+Z側に配置されているため。
        if (bodyA.position.z > bodyB.position.z) {
            frontBody = bodyA;
            backBody = bodyB;
        } else {
            frontBody = bodyB;
            backBody = bodyA;
        }

        const oldNumber = backBody.userData.number;
        const newNumber = oldNumber * 2;
        
        // スコアを加算し、UIの表示を更新
        score += newNumber;
        document.getElementById('score').innerText = 'スコア：' + score;

        // 手前側を削除
        removeCube(frontBody);

        // 奥側を新しい数字のキューブに更新
        updateCubeToNewNumber(backBody, newNumber);

        // ★改良: 斜めへ跳ね上がる挙動のパラメータ調節
        applyMergeEffects(backBody, newNumber);
    }
}

// ★改良: 合成時のエフェクト（跳ね上がり軌道の調整）
function applyMergeEffects(newBody, newNumber) {
    const mergePos = newBody.position;

    // 合成直後のキューブの速度を一度リセット
    newBody.velocity.set(0, 0, 0);
    newBody.angularVelocity.set(0, 0, 0);

    // --- パラメータ定義 ---
    const MAX_HORIZONTAL_DIST = CUBE_SIZE * 3; // 水平移動距離の最大値（仕様：1辺の3倍）
    const POPUP_IMPULSE_Y = 8.5;               // 上方向への力（滞空時間を決定）
    const gravity = Math.abs(world.gravity.y); // 重力（10）
    
    // 物理法則 v = v0 - gt から滞空時間 T を計算 (着地までの時間)
    // 頂点まで t = v0/g, 往復で T = 2 * v0 / g
    const flightTime = (2 * POPUP_IMPULSE_Y) / gravity;

    // --- ターゲット（最も近い同じ数字のキューブ）の探索 ---
    let targetBody = null;
    let minDistance = Infinity;
    const searchRadius = 6.0; // 索敵半径

    for (const obj of physicsObjects) {
        const otherBody = obj.body;
        if (otherBody === newBody) continue;

        if (otherBody.userData && otherBody.userData.isCube && otherBody.userData.number === newNumber) {
            const dist = mergePos.distanceTo(otherBody.position);
            if (dist < searchRadius && dist < minDistance) {
                minDistance = dist;
                targetBody = otherBody;
            }
        }
    }

    // インパルスベクトルの初期化
    const impulseVec = new CANNON.Vec3(0, POPUP_IMPULSE_Y, 0);

    if (targetBody) {
        // ターゲットへの方向ベクトル（水平のみ）
        const dir = new CANNON.Vec3();
        targetBody.position.vsub(mergePos, dir);
        dir.y = 0;
        
        const actualDist = dir.length();
        // 移動距離を制限値内にクランプ
        const jumpDist = Math.min(actualDist, MAX_HORIZONTAL_DIST);
        
        // 仕様：範囲内なら着地時にマージが起きるよう水平速度を規定
        // 速度 v_h = 距離 / 時間
        const horizontalVelocity = jumpDist / flightTime;

        dir.normalize();
        impulseVec.x = dir.x * horizontalVelocity;
        impulseVec.z = dir.z * horizontalVelocity;
        
        // 線形減衰(linearDamping)による速度低下を補正するため少し強める(1.25倍程度)
        const dampingComp = 1.25; 
        impulseVec.x *= dampingComp;
        impulseVec.z *= dampingComp;
    }

    // 力を適用
    newBody.applyImpulse(impulseVec, new CANNON.Vec3(0, 0, 0));

    // --- 衝撃波エフェクト（周囲のキューブを弾く） ---
    const shockwaveRadius = 2.5;
    const shockwaveForce = 4;

    for (const obj of physicsObjects) {
        const otherBody = obj.body;
        if (otherBody === newBody) continue;

        const dist = mergePos.distanceTo(otherBody.position);
        if (dist < shockwaveRadius) {
            const dir = new CANNON.Vec3();
            otherBody.position.vsub(mergePos, dir);
            const force = shockwaveForce * (1 - dist / shockwaveRadius);
            dir.normalize();
            dir.scale(force, dir);
            dir.y += force * 0.5;
            otherBody.applyImpulse(dir, new CANNON.Vec3(0, 0, 0));
        }
    }
}

// キューブの削除処理
function removeCube(body) {
    const index = physicsObjects.findIndex(obj => obj.body === body);
    if (index !== -1) {
        const obj = physicsObjects[index];
        scene.remove(obj.mesh);
        world.removeBody(body);
        physicsObjects.splice(index, 1);
    }
}

// キューブの更新処理（数字が2倍になった際）
function updateCubeToNewNumber(body, newNumber) {
    const index = physicsObjects.findIndex(obj => obj.body === body);
    if (index !== -1) {
        const obj = physicsObjects[index];
        
        // 古いメッシュをシーンから削除
        scene.remove(obj.mesh);
        
        // 色を決定。定義がないほど大きい数字の場合はデフォルト色を設定
        const color = cubeColors[newNumber] || "#333333"; 
        
        // 新しいメッシュを作成し、元の位置・回転を適用
        const newMesh = createNumberCube(newNumber, color);
        newMesh.position.copy(body.position);
        newMesh.quaternion.copy(body.quaternion);
        scene.add(newMesh);
        
        // オブジェクト情報の更新
        obj.mesh = newMesh;
        body.userData.number = newNumber;
        body.userData.isMerging = false; // マージフラグを解除して、次のマージを可能にする
    }
}

function handleKey(e, isDown) {
    if (e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a') moveLeft = isDown;
    if (e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') moveRight = isDown;

    // Enterキー押下時
    if (isDown && e.key === 'Enter') {
        shootCube();
    }
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

function animate() {
    requestAnimationFrame(animate);

    // 物理エンジンの時間を進める
    world.step(1 / 60);

    // 物理ステップ後に、衝突によって発生したマージのキューを処理する
    processMergeQueue();

    // 物理演算の結果をThree.jsのメッシュに反映
    for (const obj of physicsObjects) {
        obj.mesh.position.copy(obj.body.position);
        obj.mesh.quaternion.copy(obj.body.quaternion);
    }

    const limit = (LANE_WIDTH / 2) - (CUBE_SIZE / 2) - SIDE_MARGIN;

    // 射出前の手元のキューブの移動処理
    if (playerCube) {
        if (moveLeft) playerCube.position.x -= moveSpeed;
        if (moveRight) playerCube.position.x += moveSpeed;
        playerCube.position.x = Math.max(-limit, Math.min(limit, playerCube.position.x));
    }

    renderer.render(scene, camera);
}
</script>
</body>
</html>