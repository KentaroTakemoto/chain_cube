<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chain Cube</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #abeaff; font-family: 'Arial', sans-serif; }
        canvas { display: block; }

        #top-ui {
            position: absolute;
            top: 20px;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 0 20px;
            box-sizing: border-box;
            pointer-events: none;
        }

        .score-container {
            background: rgba(255, 255, 255, 0.8);
            padding: 5px 20px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 4px 0 rgba(0,0,0,0.1);
        }

        .best-label { font-size: 12px; color: #f57c00; font-weight: bold; }
        .score-value { font-size: 24px; font-weight: bold; color: #333; }

        #bottom-ui {
            position: absolute;
            bottom: 40px;
            width: 100%;
            display: flex;
            justify-content: center;
            gap: 30px;
            pointer-events: none;
        }

        .item-btn {
            width: 70px;
            height: 70px;
            background: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 6px 0 #ddd;
            font-size: 30px;
            position: relative;
        }

        .item-count {
            position: absolute;
            bottom: -5px;
            left: -5px;
            background: #ffb74d;
            color: white;
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 10px;
            font-weight: bold;
        }

        .instruction {
            position: absolute;
            bottom: 130px;
            width: 100%;
            text-align: center;
            color: #555;
            font-size: 14px;
            font-weight: bold;
            pointer-events: none;
        }
    </style>
</head>
<body>

<div id="top-ui">
    <div style="width: 50px;"></div>
    <div class="score-container">
        <div class="score-value" id="score">スコア：0</div>
    </div>
    <div style="width: 50px;"></div>
</div>

<div class="instruction">左右キー または A / D キーで移動</div>

<div id="bottom-ui">

</div>

<script type="importmap">
{
    "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
    }
}
</script>

<script type="module">
import * as THREE from 'three';

const CUBE_SIZE = 1;
const LANE_WIDTH = 4.5;
const LANE_LENGTH = 12;
const WALL_HEIGHT = 1.2;

/* ★ 追加：壁ぴったり防止マージン */
const SIDE_MARGIN = 0.05;

let scene, camera, renderer, playerCube;
let moveLeft = false, moveRight = false;
const moveSpeed = 0.1;

init();
animate();

function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0xabeaff);

    const aspect = window.innerWidth / window.innerHeight;
    camera = new THREE.PerspectiveCamera(40, aspect, 0.1, 1000);
    camera.position.set(0, 11, 12);
    camera.lookAt(0, -1, -2);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.9);
    scene.add(ambientLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
    dirLight.position.set(5, 15, 2);
    dirLight.castShadow = true;
    scene.add(dirLight);

    createStage();

    playerCube = createNumberCube(64, "#f06292");
    playerCube.position.set(0, CUBE_SIZE / 2, 3.5);
    scene.add(playerCube);

    window.addEventListener('keydown', (e) => handleKey(e, true));
    window.addEventListener('keyup', (e) => handleKey(e, false));
    window.addEventListener('resize', onWindowResize);
}

function createStage() {
    const stageOffsetZ = -2;

    const floorGeo = new THREE.PlaneGeometry(LANE_WIDTH, LANE_LENGTH);
    const floorMat = new THREE.MeshPhongMaterial({ color: 0xe8e8e8 });
    const floor = new THREE.Mesh(floorGeo, floorMat);
    floor.rotation.x = -Math.PI / 2;
    floor.position.z = stageOffsetZ;
    floor.receiveShadow = true;
    scene.add(floor);

    const lineMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 });
    for(let i = 0; i < 3; i++) {
        const dash = new THREE.Mesh(new THREE.PlaneGeometry(0.8, 0.15), lineMat);
        dash.rotation.x = -Math.PI / 2;
        dash.position.set((i - 1) * 1.4, 0.01, 1.5);
        scene.add(dash);
    }

    const wallMat = new THREE.MeshPhongMaterial({ color: 0xe6a15c });

    const sideWallGeo = new THREE.BoxGeometry(0.2, WALL_HEIGHT, LANE_LENGTH);

    const leftWall = new THREE.Mesh(sideWallGeo, wallMat);
    leftWall.position.set(-(LANE_WIDTH / 2 + 0.1), WALL_HEIGHT / 2, stageOffsetZ);
    scene.add(leftWall);

    const rightWall = new THREE.Mesh(sideWallGeo, wallMat);
    rightWall.position.set(LANE_WIDTH / 2 + 0.1, WALL_HEIGHT / 2, stageOffsetZ);
    scene.add(rightWall);

    const backWallGeo = new THREE.BoxGeometry(LANE_WIDTH + 0.4, WALL_HEIGHT, 0.2);
    const backWall = new THREE.Mesh(backWallGeo, wallMat);
    backWall.position.set(0, WALL_HEIGHT / 2, -LANE_LENGTH / 2 + stageOffsetZ);
    scene.add(backWall);
}

function createNumberCube(number, color) {
    const group = new THREE.Group();
    const geometry = new THREE.BoxGeometry(CUBE_SIZE, CUBE_SIZE, CUBE_SIZE);
    const material = new THREE.MeshPhongMaterial({ color: color });
    const mesh = new THREE.Mesh(geometry, material);
    mesh.castShadow = true;
    group.add(mesh);

    const canvas = document.createElement('canvas');
    canvas.width = 128; canvas.height = 128;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = color;
    ctx.fillRect(0, 0, 128, 128);
    ctx.fillStyle = 'white';
    ctx.font = 'Bold 75px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(number, 64, 64);

    const texture = new THREE.CanvasTexture(canvas);
    const textMat = new THREE.MeshBasicMaterial({ map: texture, transparent: true });
    const textGeom = new THREE.PlaneGeometry(0.9, 0.9);

    const offsets = [
        { pos: [0, 0, 0.51], rot: [0, 0, 0] },
        { pos: [0, 0, -0.51], rot: [0, Math.PI, 0] },
        { pos: [0, 0.51, 0], rot: [-Math.PI / 2, 0, 0] },
        { pos: [0, -0.51, 0], rot: [Math.PI / 2, 0, 0] },
        { pos: [0.51, 0, 0], rot: [0, Math.PI / 2, 0] },
        { pos: [-0.51, 0, 0], rot: [0, -Math.PI / 2, 0] }
    ];

    offsets.forEach(o => {
        const p = new THREE.Mesh(textGeom, textMat);
        p.position.set(...o.pos);
        p.rotation.set(...o.rot);
        group.add(p);
    });

    return group;
}

function handleKey(e, isDown) {
    if (e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a') moveLeft = isDown;
    if (e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') moveRight = isDown;
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

function animate() {
    requestAnimationFrame(animate);

    const limit = (LANE_WIDTH / 2) - (CUBE_SIZE / 2) - SIDE_MARGIN;

    if (moveLeft) playerCube.position.x -= moveSpeed;
    if (moveRight) playerCube.position.x += moveSpeed;

    /* ★ 物理誤差対策クランプ */
    playerCube.position.x = Math.max(-limit, Math.min(limit, playerCube.position.x));

    renderer.render(scene, camera);
}
</script>
</body>
</html>